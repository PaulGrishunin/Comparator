"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var NodeIPC = require("node-ipc");
var webpack = require("webpack");
var MessageEmitter_1 = require("./MessageEmitter");
var hooks_1 = require("./hooks");
var Configuration_1 = require("./Configuration");
exports.WEBPACK_PLUGIN_NAME = 'overpack';
exports.run = function (opts) { return new Promise(function (resolve) {
    var config = Configuration_1.loadConfig(opts.configPath, opts.env)[opts.configIndex];
    var compiler = webpack(config);
    var ipc = new NodeIPC.IPC();
    ipc.config.silent = true;
    ipc.connectTo(opts.ipcChannel);
    var workerId = config.name || "Configuration " + opts.configIndex;
    var emit = ipc.of[opts.ipcChannel].emit.bind(ipc.of[opts.ipcChannel]);
    var messageEmitter = new MessageEmitter_1.MessageEmitter(workerId, emit);
    tapCompilerHooks(workerId, compiler, messageEmitter);
    tapOverpackTaskHooks(compiler, messageEmitter);
    if (opts.watch) {
        compiler.watch({}, function () { });
    }
    else {
        compiler.run(function () { return resolve(); });
    }
}); };
function tapCompilerHooks(rootTaskId, compiler, messageEmitter) {
    var COMPILE_TASK_ID = 'Compile';
    var EMIT_TASK_ID = 'Emit';
    compiler.hooks.compile.tap(exports.WEBPACK_PLUGIN_NAME, function () {
        messageEmitter.triggerBuild();
        messageEmitter.createTask(COMPILE_TASK_ID);
        messageEmitter.createTask(EMIT_TASK_ID);
        messageEmitter.startTask(COMPILE_TASK_ID);
    });
    compiler.hooks.afterCompile.tap(exports.WEBPACK_PLUGIN_NAME, function (compilation) {
        if (compilation.errors && compilation.errors.length > 0) {
            messageEmitter.failTask(COMPILE_TASK_ID);
            messageEmitter.skipTask(EMIT_TASK_ID);
        }
        else {
            messageEmitter.succeedTask(COMPILE_TASK_ID);
        }
    });
    compiler.hooks.emit.tap(exports.WEBPACK_PLUGIN_NAME, function () { return messageEmitter.startTask(EMIT_TASK_ID); });
    compiler.hooks.afterEmit.tap(exports.WEBPACK_PLUGIN_NAME, function (compilation) {
        if (compilation.errors && compilation.errors.length > 0) {
            messageEmitter.failTask(EMIT_TASK_ID);
        }
        else {
            messageEmitter.succeedTask(EMIT_TASK_ID);
        }
    });
    compiler.hooks.failed.tap(exports.WEBPACK_PLUGIN_NAME, function (error) {
        if (error) {
            messageEmitter.error(error.stack);
        }
    });
    compiler.hooks.done.tap(exports.WEBPACK_PLUGIN_NAME, function (stats) {
        var info = stats.toJson();
        if (stats.hasWarnings()) {
            info.warnings.forEach(function (warning) { return messageEmitter.warning(warning); });
        }
        if (stats.hasErrors()) {
            info.errors.forEach(function (error) { return messageEmitter.error(error); });
        }
    });
}
exports.tapCompilerHooks = tapCompilerHooks;
function tapOverpackTaskHooks(compiler, messageEmitter) {
    var hooks = hooks_1.getOverpackHooks(compiler);
    hooks.error.tap(exports.WEBPACK_PLUGIN_NAME, function (msg) { return messageEmitter.error(msg); });
    hooks.warning.tap(exports.WEBPACK_PLUGIN_NAME, function (msg) { return messageEmitter.warning(msg); });
    hooks.createTask.tap(exports.WEBPACK_PLUGIN_NAME, function (taskId) { return messageEmitter.createTask(taskId); });
    hooks.startTask.tap(exports.WEBPACK_PLUGIN_NAME, function (taskId) { return messageEmitter.startTask(taskId); });
    hooks.succeedTask.tap(exports.WEBPACK_PLUGIN_NAME, function (taskId) { return messageEmitter.succeedTask(taskId); });
    hooks.failTask.tap(exports.WEBPACK_PLUGIN_NAME, function (taskId) { return messageEmitter.failTask(taskId); });
}
exports.tapOverpackTaskHooks = tapOverpackTaskHooks;
//# sourceMappingURL=WebpackWorker.js.map